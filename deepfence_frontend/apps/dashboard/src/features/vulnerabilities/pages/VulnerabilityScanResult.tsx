import cx from 'classnames';
import { memo, Suspense, useMemo, useRef, useState } from 'react';
import { RefObject } from 'react';
import { IconContext } from 'react-icons';
import { FiFilter } from 'react-icons/fi';
import { HiArrowSmLeft, HiClock, HiDotsVertical, HiRefresh } from 'react-icons/hi';
import {
  Await,
  Form,
  LoaderFunctionArgs,
  useLoaderData,
  useParams,
  useSearchParams,
} from 'react-router-dom';
import {
  Badge,
  Button,
  CircleSpinner,
  createColumnHelper,
  Dropdown,
  DropdownItem,
  getRowSelectionColumn,
  Table,
  TableSkeleton,
} from 'ui-components';
import { Checkbox, ModalHeader, Select, SelectItem, SlidingModal } from 'ui-components';

import { getVulnerabilityApiClient } from '@/api/api';
import {
  ApiDocsBadRequestResponse,
  ModelVulnerabilityScanConfigLanguageLanguageEnum,
} from '@/api/generated';
import { DFLink } from '@/components/DFLink';
import { VulnerabilityIcon } from '@/components/sideNavigation/icons/Vulnerability';
import { IconMapForNodeType } from '@/features/onboard/components/IconMapForNodeType';
import { ApiError, makeRequest } from '@/utils/api';
import { formatMilliseconds } from '@/utils/date';
import { typedDefer, TypedDeferredData } from '@/utils/router';
import { usePageNavigation } from '@/utils/usePageNavigation';

export interface FocusableElement {
  focus(options?: FocusOptions): void;
}

const packages = [
  // {
  //   name: 'OS Packages',
  //   checked: false,
  //   value: ModelVulnerabilityScanConfigLanguageLanguageEnum.OsPackages,
  // },
  {
    name: 'Java',
    checked: false,
    value: ModelVulnerabilityScanConfigLanguageLanguageEnum.Java,
  },
  {
    name: 'Javascript',
    checked: false,
    value: ModelVulnerabilityScanConfigLanguageLanguageEnum.Javascript,
  },
  {
    name: 'Rust',
    checked: false,
    value: ModelVulnerabilityScanConfigLanguageLanguageEnum.Rust,
  },
  {
    name: 'GoLang',
    checked: false,
    value: ModelVulnerabilityScanConfigLanguageLanguageEnum.Golang,
  },
  {
    name: 'Ruby',
    checked: false,
    value: ModelVulnerabilityScanConfigLanguageLanguageEnum.Ruby,
  },
  {
    name: 'Python',
    checked: false,
    value: ModelVulnerabilityScanConfigLanguageLanguageEnum.Python,
  },
  {
    name: 'PHP',
    checked: false,
    value: ModelVulnerabilityScanConfigLanguageLanguageEnum.Php,
  },
  {
    name: 'Dotnet',
    checked: false,
    value: ModelVulnerabilityScanConfigLanguageLanguageEnum.Dotnet,
  },
];

enum NodeTypeEnum {
  Host = 'host',
  Container = 'container',
  Image = 'container_image',
}

type ScanResult = {
  nodeType: string;
  scanId: string;
  nodeName: string;
  timestamp: number;
  status: string;
  total: number;
  critical: number;
  high: number;
  medium: number;
  low: number;
  action?: null;
};

export type LoaderDataType = {
  error?: string;
  message?: string;
  data: ScanResult[];
  containerImages?: {
    nodeId: string;
    containerImage: string;
  }[];
  containers?: {
    nodeId: string;
    nodeName: string;
  }[];
  hosts?: {
    nodeId: string;
    hostName: string;
  }[];
};

const getStatusSearch = (searchParams: URLSearchParams) => {
  return searchParams.getAll('status').map((status) => status.toUpperCase());
};
const getHostsSearch = (searchParams: URLSearchParams) => {
  return searchParams.getAll('hosts');
};
const getContainersSearch = (searchParams: URLSearchParams) => {
  return searchParams.getAll('containers');
};
const getContainerImagesSearch = (searchParams: URLSearchParams) => {
  return searchParams.getAll('images');
};
const getLanguagesSearch = (searchParams: URLSearchParams) => {
  return searchParams.getAll('languages');
};

async function getContainerImages(): Promise<LoaderDataType['containerImages']> {
  const result = await makeRequest({
    apiFunction: getVulnerabilityApiClient().searchContainerImages,
    apiArgs: [
      {
        searchSearchNodeReq: {
          node_filter: {
            filters: {
              contains_filter: {
                filter_in: {},
              },
              order_filter: {
                order_field: 'vulnerabilities_count',
              },
              match_filter: {
                filter_in: {},
              },
            },
            in_field_filter: null,
          },
          window: {
            offset: 0,
            size: 1000,
          },
        },
      },
    ],
    errorHandler: async (r) => {
      const error = new ApiError<LoaderDataType>({ data: [] });
      if (r.status === 400) {
        const modelResponse: ApiDocsBadRequestResponse = await r.json();
        return error.set({
          message: modelResponse.message,
          data: [],
        });
      }
    },
  });

  if (ApiError.isApiError(result)) {
    throw result.value();
  }

  if (result === null) {
    return [];
  }
  return result.map((res) => {
    return {
      nodeId: res.node_id,
      containerImage: `${res.docker_image_name}:${res.docker_image_tag}`,
    };
  });
}

async function getContainers(): Promise<LoaderDataType['containers']> {
  const result = await makeRequest({
    apiFunction: getVulnerabilityApiClient().searchContainers,
    apiArgs: [
      {
        searchSearchNodeReq: {
          node_filter: {
            filters: {
              contains_filter: {
                filter_in: {},
              },
              order_filter: {
                order_field: 'vulnerabilities_count',
              },
              match_filter: {
                filter_in: {},
              },
            },
            in_field_filter: null,
          },
          window: {
            offset: 0,
            size: 1000,
          },
        },
      },
    ],
    errorHandler: async (r) => {
      const error = new ApiError<LoaderDataType>({ data: [] });
      if (r.status === 400) {
        const modelResponse: ApiDocsBadRequestResponse = await r.json();
        return error.set({
          message: modelResponse.message,
          data: [],
        });
      }
    },
  });

  if (ApiError.isApiError(result)) {
    throw result.value();
  }

  if (result === null) {
    return [];
  }
  return result.map((res) => {
    return {
      nodeId: res.node_id,
      nodeName: res.docker_container_name,
    };
  });
}

async function getHosts(): Promise<LoaderDataType['hosts']> {
  const result = await makeRequest({
    apiFunction: getVulnerabilityApiClient().searchHosts,
    apiArgs: [
      {
        searchSearchNodeReq: {
          node_filter: {
            filters: {
              contains_filter: {
                filter_in: {},
              },
              order_filter: {
                order_field: 'vulnerabilities_count',
              },
              match_filter: {
                filter_in: {},
              },
            },
            in_field_filter: null,
          },
          window: {
            offset: 0,
            size: 1000,
          },
        },
      },
    ],
    errorHandler: async (r) => {
      const error = new ApiError<LoaderDataType>({ data: [] });
      if (r.status === 400) {
        const modelResponse: ApiDocsBadRequestResponse = await r.json();
        return error.set({
          message: modelResponse.message,
          data: [],
        });
      }
    },
  });

  if (ApiError.isApiError(result)) {
    throw result.value();
  }

  if (result === null) {
    return [];
  }
  return result.map((res) => {
    return {
      nodeId: res.node_id,
      hostName: res.host_name,
    };
  });
}

async function getScans(
  nodeTypes: NodeTypeEnum[],
  searchParams: URLSearchParams,
): Promise<ScanResult[]> {
  const status = getStatusSearch(searchParams);
  const scanFilters = {} as {
    status?: string[];
  };
  if (status.length > 0) {
    scanFilters.status = status;
  }

  const nodeFilters = {
    node_type: nodeTypes,
  } as {
    status?: string[];
    node_type?: string[];
    node_id?: string[];
  };
  const hosts = getHostsSearch(searchParams);
  const containers = getContainersSearch(searchParams);
  const images = getContainerImagesSearch(searchParams);
  const languages = getLanguagesSearch(searchParams);

  if (hosts && hosts?.length > 0) {
    nodeFilters.node_id = nodeFilters.node_id ? nodeFilters.node_id.concat(hosts) : hosts;
  }
  if (containers && containers?.length > 0) {
    nodeFilters.node_id = nodeFilters.node_id
      ? nodeFilters.node_id.concat(containers)
      : containers;
  }
  if (images && images?.length > 0) {
    nodeFilters.node_id = nodeFilters.node_id
      ? nodeFilters.node_id.concat(images)
      : images;
  }
  if (languages && languages?.length > 0) {
    nodeFilters.node_id = nodeFilters.node_id
      ? nodeFilters.node_id.concat(languages)
      : languages;
  }

  const languageFilters = {} as {
    trigger_action: string[];
  };
  if (languages && languages.length > 0) {
    languageFilters.trigger_action = languages;
  }

  const result = await makeRequest({
    apiFunction: getVulnerabilityApiClient().searchVulnerabilityScan,
    apiArgs: [
      {
        searchSearchScanReq: {
          node_filters: {
            filters: {
              contains_filter: {
                filter_in: {
                  ...nodeFilters,
                },
              },
              order_filter: {
                order_field: '',
              },
              match_filter: {
                filter_in: {},
              },
            },
            in_field_filter: null,
          },
          scan_filters: {
            filters: {
              contains_filter: {
                filter_in: {
                  ...scanFilters,
                },
              },
              order_filter: {
                order_field: '',
              },
              match_filter: { filter_in: { ...languageFilters } },
            },
            in_field_filter: null,
          },
          window: {
            offset: 0,
            size: 1000,
          },
        },
      },
    ],
    errorHandler: async (r) => {
      const error = new ApiError<LoaderDataType>({ data: [] });
      if (r.status === 400) {
        const modelResponse: ApiDocsBadRequestResponse = await r.json();
        return error.set({
          message: modelResponse.message,
          data: [],
        });
      }
    },
  });

  if (ApiError.isApiError(result)) {
    throw result.value();
  }

  if (result === null) {
    return [];
  }
  return result.map((res) => {
    const severities = res.severity_counts as {
      critical: number;
      high: number;
      medium: number;
      low: number;
    };
    severities.critical = severities.critical ?? 0;
    severities.high = severities.high ?? 0;
    severities.medium = severities.medium ?? 0;
    severities.low = severities.low ?? 0;

    return {
      nodeType: res.node_type,
      scanId: res.scan_id,
      nodeName: res.node_id,
      timestamp: res.updated_at,
      status: res.status,
      total: severities.critical + severities.high + severities.medium + severities.low,
      critical: severities.critical,
      high: severities.high,
      medium: severities.medium,
      low: severities.low,
    };
  });
}

const loader = async ({
  request,
}: LoaderFunctionArgs): Promise<TypedDeferredData<LoaderDataType>> => {
  const searchParams = new URL(request.url).searchParams;

  const nodeType = searchParams.getAll('nodeType').length
    ? searchParams.getAll('nodeType')
    : ['container_image', 'container', 'host'];

  // const lists = await Promise.all([getHosts(), getContainers(), getContainerImages()]);
  return typedDefer({
    data: getScans(nodeType as NodeTypeEnum[], searchParams),
    hosts: getHosts(),
    containers: getContainers(),
    containerImages: getContainerImages(),
  });
};

const FilterHeader = () => {
  return (
    <ModalHeader>
      <div className="flex gap-x-2 items-center p-4">
        <span className="font-medium text-lg">Filters</span>
      </div>
    </ModalHeader>
  );
};

const FilterModal = memo(
  ({
    showFilter,
    elementToFocusOnClose,
    setShowFilter,
  }: {
    elementToFocusOnClose: RefObject<FocusableElement> | null;
    showFilter: boolean;
    setShowFilter: React.Dispatch<React.SetStateAction<boolean>>;
  }) => {
    const loader = useLoaderData() as LoaderDataType;

    const [searchParams, setSearchParams] = useSearchParams();
    return (
      <SlidingModal
        header={<FilterHeader />}
        open={showFilter}
        onOpenChange={() => setShowFilter(false)}
        elementToFocusOnCloseRef={elementToFocusOnClose}
        width={'w-[350px]'}
      >
        <div className="dark:text-white p-4">
          <Form className="flex flex-col gap-y-6">
            <fieldset>
              <legend className="text-sm font-medium">Status</legend>
              <div className="flex gap-x-4">
                <Checkbox
                  label="Completed"
                  checked={searchParams.getAll('status').includes('complete')}
                  onCheckedChange={(state) => {
                    if (state) {
                      setSearchParams((prev) => {
                        prev.append('status', 'complete');
                        return prev;
                      });
                    } else {
                      setSearchParams((prev) => {
                        const prevStatuses = prev.getAll('status');
                        prev.delete('status');
                        prevStatuses
                          .filter((status) => status !== 'complete')
                          .forEach((status) => {
                            prev.append('status', status);
                          });
                        return prev;
                      });
                    }
                  }}
                />
                <Checkbox
                  label="In Progress"
                  checked={searchParams.getAll('status').includes('in_progress')}
                  onCheckedChange={(state) => {
                    if (state) {
                      setSearchParams((prev) => {
                        prev.append('status', 'in_progress');
                        return prev;
                      });
                    } else {
                      setSearchParams((prev) => {
                        const prevStatuses = prev.getAll('status');
                        prev.delete('status');
                        prevStatuses
                          .filter((status) => status !== 'in_progress')
                          .forEach((status) => {
                            prev.append('status', status);
                          });
                        return prev;
                      });
                    }
                  }}
                />
                <Checkbox
                  label="Error"
                  checked={searchParams.getAll('status').includes('error')}
                  onCheckedChange={(state) => {
                    if (state) {
                      setSearchParams((prev) => {
                        prev.append('status', 'error');
                        return prev;
                      });
                    } else {
                      setSearchParams((prev) => {
                        const prevStatuses = prev.getAll('status');
                        prev.delete('status');
                        prevStatuses
                          .filter((status) => status !== 'error')
                          .forEach((status) => {
                            prev.append('status', status);
                          });
                        return prev;
                      });
                    }
                  }}
                />
              </div>
            </fieldset>
            <fieldset>
              <Select
                name="language"
                label={'Language'}
                placeholder="Select language"
                value={searchParams.getAll('languages')}
                sizing="xs"
                onChange={(value) => {
                  setSearchParams((prev) => {
                    prev.delete('languages');
                    value.forEach((language) => {
                      prev.append('languages', language);
                    });
                    return prev;
                  });
                }}
              >
                {packages.map((pkg: { name: string }) => {
                  return <SelectItem value={pkg.name} key={pkg.name} />;
                })}
              </Select>
            </fieldset>
            <fieldset>
              <Suspense fallback={<CircleSpinner size="xs" />}>
                <Await resolve={loader.hosts}>
                  {(resolvedData: LoaderDataType['hosts']) => {
                    return (
                      <Select
                        name="host"
                        label={'Host'}
                        placeholder="Select host"
                        sizing="xs"
                        value={searchParams.getAll('hosts')}
                        onChange={(value) => {
                          setSearchParams((prev) => {
                            prev.delete('hosts');
                            value.forEach((host) => {
                              prev.append('hosts', host);
                            });
                            return prev;
                          });
                        }}
                      >
                        <>
                          {resolvedData?.map((host) => {
                            return (
                              <SelectItem value={host.hostName} key={host.hostName} />
                            );
                          })}
                        </>
                      </Select>
                    );
                  }}
                </Await>
              </Suspense>
            </fieldset>
            <fieldset>
              <Suspense fallback={<CircleSpinner size="xs" />}>
                <Await resolve={loader.containers}>
                  {(resolvedData: LoaderDataType['containers']) => {
                    return (
                      <Select
                        name="container"
                        label={'Container'}
                        placeholder="Select container"
                        sizing="xs"
                        value={searchParams.getAll('containers')}
                        onChange={(value) => {
                          setSearchParams((prev) => {
                            prev.delete('containers');
                            value.forEach((container) => {
                              prev.append('containers', container);
                            });
                            return prev;
                          });
                        }}
                      >
                        {resolvedData?.map((container) => {
                          return (
                            <SelectItem value={container.nodeId} key={container.nodeId} />
                          );
                        })}
                      </Select>
                    );
                  }}
                </Await>
              </Suspense>
            </fieldset>
            <fieldset>
              <Suspense fallback={<CircleSpinner size="xs" />}>
                <Await resolve={loader.containerImages}>
                  {(resolvedData: LoaderDataType['containerImages']) => {
                    return (
                      <Select
                        name="image"
                        label={'Image'}
                        placeholder="Select image"
                        sizing="xs"
                        value={searchParams.getAll('containerImages')}
                        onChange={(value) => {
                          setSearchParams((prev) => {
                            prev.delete('containerImages');
                            value.forEach((containerImage) => {
                              prev.append('containerImages', containerImage);
                            });
                            return prev;
                          });
                        }}
                      >
                        {resolvedData?.map?.((image) => {
                          return (
                            <SelectItem
                              value={image.containerImage}
                              key={image.containerImage}
                            />
                          );
                        })}
                      </Select>
                    );
                  }}
                </Await>
              </Suspense>
            </fieldset>
            <fieldset>
              <Select
                name="cluster"
                label={'Cluster'}
                placeholder="Select cluster"
                sizing="xs"
              >
                {packages.map((pkg: { name: string }) => {
                  return <SelectItem value={pkg.name} key={pkg.name} />;
                })}
              </Select>
            </fieldset>
          </Form>
        </div>
      </SlidingModal>
    );
  },
);

const ScanFromDropdown = () => {
  return (
    <Dropdown
      triggerAsChild={true}
      content={
        <>
          <DropdownItem className="text-xs">Last 12 hours</DropdownItem>
          <DropdownItem className="text-xs">Last 24 hours</DropdownItem>
          <DropdownItem className="text-xs">Last 7 days</DropdownItem>
          <DropdownItem className="text-xs">Last 30 days</DropdownItem>
          <DropdownItem className="text-xs">Last 60 days</DropdownItem>
          <DropdownItem className="text-xs">Last 90 days</DropdownItem>
          <DropdownItem className="text-xs">Last 6 months</DropdownItem>
          <DropdownItem className="text-xs">Show All</DropdownItem>
        </>
      }
    >
      <Button
        className="ml-auto bg-blue-100 dark:bg-blue-500/10"
        size="xs"
        color="normal"
      >
        <IconContext.Provider
          value={{
            className: 'w-4 h-4',
          }}
        >
          <HiClock />
        </IconContext.Provider>
      </Button>
    </Dropdown>
  );
};

const RefreshApiDropdown = () => {
  return (
    <Dropdown
      triggerAsChild={true}
      content={
        <>
          <DropdownItem className="text-xs">1 minute</DropdownItem>
          <DropdownItem className="text-xs">5 minutes</DropdownItem>
          <DropdownItem className="text-xs">15 minutes</DropdownItem>
          <DropdownItem className="text-xs">1 hour</DropdownItem>
          <DropdownItem className="text-xs">2 hours</DropdownItem>
          <DropdownItem className="text-xs">12 hours</DropdownItem>
          <DropdownItem className="text-xs">1 day</DropdownItem>
        </>
      }
    >
      <Button
        className="ml-auto bg-blue-100 dark:bg-blue-500/10"
        size="xs"
        color="normal"
      >
        <IconContext.Provider
          value={{
            className: 'w-4 h-4',
          }}
        >
          <HiRefresh />
        </IconContext.Provider>
      </Button>
    </Dropdown>
  );
};

const VulnerabilityScanResult = () => {
  const params = useParams() as {
    nodeType: string;
  };
  const [searchParams, setSearchParams] = useSearchParams();

  const nodeType = params.nodeType;

  const elementToFocusOnClose = useRef(null);
  const [showFilter, setShowFilter] = useState(false);
  const loaderData = useLoaderData() as LoaderDataType;
  const totalRows = 10;

  const [{ pageIndex, pageSize }, setPagination] = useState({
    pageIndex: 0,
    pageSize: 15,
  });

  const { navigate } = usePageNavigation();

  const columnHelper = createColumnHelper<ScanResult>();
  const columns = useMemo(() => {
    const columns = [
      getRowSelectionColumn(columnHelper, {
        size: 0,
        minSize: 0,
        maxSize: 0,
      }),
      columnHelper.accessor('nodeType', {
        enableSorting: false,
        cell: (info) => {
          return (
            <div className="flex items-center gap-x-2">
              <div className="bg-blue-100 dark:bg-blue-500/10 p-2 rounded-lg">
                <IconContext.Provider
                  value={{ className: 'w-5 h-5 text-blue-500 dark:text-blue-400' }}
                >
                  {IconMapForNodeType[info.getValue()]}
                </IconContext.Provider>
              </div>
              <span className="capitalize">{info.getValue()?.replaceAll('_', ' ')}</span>
            </div>
          );
        },
        header: () => 'Type',
        minSize: 300,
        size: 300,
        maxSize: 300,
      }),
      columnHelper.accessor('nodeName', {
        enableSorting: false,
        cell: (info) => (
          <DFLink
            to="#"
            onClick={(e) => {
              e.preventDefault();
              navigate(
                `/vulnerability/scan-results/${nodeType}/${info.row.original.scanId}`,
                {
                  state: {
                    updatedAt: info.row.original.timestamp,
                    severityCounts: {
                      critical: info.row.original.critical,
                      medium: info.row.original.medium,
                      high: info.row.original.high,
                      low: info.row.original.low,
                      total: info.row.original.total,
                    },
                  },
                },
              );
            }}
          >
            <div className="flex items-center gap-x-2">
              <IconContext.Provider
                value={{ className: 'w-5 h-5 text-blue-500 dark:text-blue-400' }}
              >
                {IconMapForNodeType[info.getValue()]}
              </IconContext.Provider>
              <span className="capitalize">{info.getValue()?.replaceAll('_', ' ')}</span>
            </div>
          </DFLink>
        ),
        header: () => 'Name',
        minSize: 600,
        size: 600,
        maxSize: 600,
      }),
      columnHelper.accessor('timestamp', {
        cell: (info) => (
          <div className="flex items-center gap-x-2">
            <IconContext.Provider value={{ className: 'text-gray-400' }}>
              <HiClock />
            </IconContext.Provider>
            {formatMilliseconds(info.getValue())}
          </div>
        ),
        header: () => 'Timestamp',
        minSize: 400,
        size: 400,
        maxSize: 400,
      }),
      columnHelper.accessor('status', {
        enableSorting: false,
        cell: (info) => (
          <Badge
            label={info.getValue().toLowerCase()}
            className={cx({
              'bg-green-100 dark:bg-green-600/10 text-green-600 dark:text-green-400':
                info.getValue().toLowerCase() === 'complete',
              'bg-red-100 dark:bg-red-600/10 text-red-600 dark:text-red-400':
                info.getValue().toLowerCase() === 'error',
              'bg-blue-100 dark:bg-blue-600/10 text-blue-600 dark:text-blue-400':
                info.getValue().toLowerCase() === 'in_progress',
            })}
            size="sm"
          />
        ),
        header: () => 'Status',
        minSize: 100,
        size: 100,
        maxSize: 100,
      }),
      columnHelper.accessor('total', {
        enableSorting: true,
        cell: (info) => (
          <div className="flex items-center gap-x-2">
            <div className="w-5 h-5 text-gray-400">
              <VulnerabilityIcon />
            </div>
            {info.getValue()}
          </div>
        ),
        header: () => 'Total',
        minSize: 100,
        size: 150,
        maxSize: 150,
      }),
      columnHelper.accessor('critical', {
        enableSorting: false,
        cell: (info) => (
          <div className="flex items-center gap-x-2">
            <div className="w-2 h-2 bg-red-400 dark:bg-red-500 rounded-full"></div>
            {info.getValue()}
          </div>
        ),
        header: () => '',
        minSize: 100,
        size: 150,
        maxSize: 150,
      }),
      columnHelper.accessor('high', {
        enableSorting: false,
        cell: (info) => (
          <div className="flex items-center gap-x-2">
            <div className="w-2 h-2 bg-pink-400 dark:bg-pink-500 rounded-full"></div>
            {info.getValue()}
          </div>
        ),
        header: () => '',
        minSize: 100,
        size: 100,
        maxSize: 100,
      }),
      columnHelper.accessor('medium', {
        enableSorting: false,
        cell: (info) => (
          <div className="flex items-center gap-x-2">
            <div className="w-2 h-2 bg-blue-400 dark:bg-blue-500 rounded-full"></div>
            {info.getValue()}
          </div>
        ),
        header: () => '',
        minSize: 100,
        size: 100,
        maxSize: 100,
      }),
      columnHelper.accessor('low', {
        enableSorting: false,
        cell: (info) => (
          <div className="flex items-center gap-x-2">
            <div className="w-2 h-2 bg-yellow-300 dark:bg-yellow-500 rounded-full"></div>
            {info.getValue()}
          </div>
        ),
        header: () => '',
        minSize: 100,
        size: 100,
        maxSize: 100,
      }),
      columnHelper.accessor('action', {
        enableSorting: false,
        cell: () => (
          <IconContext.Provider value={{ className: 'text-gray-700 dark:text-gray-400' }}>
            <HiDotsVertical />
          </IconContext.Provider>
        ),
        header: () => '',
        minSize: 10,
      }),
    ];

    return columns;
  }, []);

  const isFilterApplied =
    searchParams.has('languages') ||
    searchParams.has('containerImages') ||
    searchParams.has('containers') ||
    searchParams.has('nodeType') ||
    searchParams.has('hosts');

  return (
    <div>
      <FilterModal
        showFilter={showFilter}
        setShowFilter={setShowFilter}
        elementToFocusOnClose={elementToFocusOnClose.current}
      />
      <div className="flex p-1 pl-2 w-full items-center shadow bg-white dark:bg-gray-800">
        <DFLink
          to={'/vulnerability'}
          className="flex hover:no-underline items-center justify-center mr-2"
        >
          <IconContext.Provider
            value={{
              className: 'w-5 h-5 text-blue-600 dark:text-blue-500 ',
            }}
          >
            <HiArrowSmLeft />
          </IconContext.Provider>
        </DFLink>
        <span className="text-sm font-medium text-gray-700 dark:text-gray-200">
          VULNERABILITY SCAN RESULTS
        </span>
        <div className="ml-auto flex gap-x-4">
          <ScanFromDropdown />
          <RefreshApiDropdown />
          <div className="relative gap-x-4">
            {isFilterApplied && (
              <span className="absolute left-0 top-0 inline-flex h-2 w-2 rounded-full bg-blue-400 opacity-75"></span>
            )}

            <Button
              className="ml-auto bg-blue-100 dark:bg-blue-500/10"
              size="xs"
              color="normal"
              ref={elementToFocusOnClose}
              onClick={() => {
                setShowFilter(true);
              }}
            >
              <IconContext.Provider
                value={{
                  className: 'w-4 h-4',
                }}
              >
                <FiFilter />
              </IconContext.Provider>
            </Button>
          </div>
        </div>
      </div>
      <div className="m-2">
        <Suspense fallback={<TableSkeleton columns={10} rows={10} size={'md'} />}>
          <Await resolve={loaderData.data}>
            {(resolvedData: ScanResult[]) => {
              return (
                <Table
                  size="sm"
                  data={resolvedData}
                  columns={columns}
                  enableRowSelection
                  enableSorting
                  enablePagination
                  manualPagination
                  totalRows={totalRows}
                  pageSize={pageSize}
                  pageIndex={pageIndex}
                  onPaginationChange={setPagination}
                />
              );
            }}
          </Await>
        </Suspense>
      </div>
    </div>
  );
};

export const module = {
  loader,
  element: <VulnerabilityScanResult />,
};
