package ingesters

import (
	"context"
	"encoding/json"
	"github.com/deepfence/ThreatMapper/deepfence_utils/log"
	"github.com/deepfence/ThreatMapper/deepfence_utils/utils"
	"github.com/deepfence/ThreatMapper/deepfence_worker/ingesters"
	"github.com/twmb/franz-go/pkg/kgo"

	"github.com/deepfence/ThreatMapper/deepfence_utils/directory"
)

type MalwareIngester struct{}

type Malware struct {
	DocId               string `json:"doc_id"`
	Timestamp           string `json:"@timestamp"`
	Count               int    `json:"count,omitempty"`
	Reason              string `json:"reason"`
	Resource            string `json:"resource"`
	Status              string `json:"status"`
	Region              string `json:"region"`
	AccountID           string `json:"account_id"`
	Group               string `json:"group"`
	Service             string `json:"service"`
	Title               string `json:"title"`
	ComplianceCheckType string `json:"compliance_check_type"`
	CloudProvider       string `json:"cloud_provider"`
	NodeName            string `json:"node_name"`
	NodeID              string `json:"node_id"`
	ScanID              string `json:"scan_id"`
	Masked              string `json:"masked"`
	Type                string `json:"type"`
	ControlID           string `json:"control_id"`
	Description         string `json:"description"`
	Severity            string `json:"severity"`
}

func NewMalwareIngester() KafkaIngester[[]map[string]interface{}] {
	return &MalwareIngester{}
}

func (tc *MalwareIngester) Ingest(
	ctx context.Context,
	cs []map[string]interface{},
	ingestC chan *kgo.Record,
) error {
	tenantID, err := directory.ExtractNamespace(ctx)
	if err != nil {
		return err
	}

	rh := []kgo.RecordHeader{
		{Key: "tenant_id", Value: []byte(tenantID)},
	}

	for _, c := range cs {
		cb, err := json.Marshal(c)
		if err != nil {
			log.Error().Msg(err.Error())
		} else {
			ingestC <- &kgo.Record{
				Topic:   utils.MALWARE_SCAN,
				Value:   cb,
				Headers: rh,
			}
		}
	}

	return nil
}

//func (tc *MalwareIngester) Ingest(ctx context.Context,
//	cs []map[string]interface{},
//	ingestC chan *kgo.Record) error {
//	driver, err := directory.Neo4jClient(ctx)
//	session, err := driver.Session(neo4j.AccessModeWrite)
//
//	rh := []kgo.RecordHeader{
//		{Key: "tenant_id", Value: []byte(tenantID)},
//	}
//
//	if err != nil {
//		return err
//	}
//	defer session.Close()
//
//	tx, err := session.BeginTransaction()
//	if err != nil {
//		return err
//	}
//	defer tx.Close()
//
//	malwareMap := []map[string]interface{}{}
//	for _, i := range cs {
//		malware := map[string]interface{}{}
//		match := i["StringsToMatch"].([]string)
//		metaRules := i["MetaRules"].(map[string]string)
//		meta := i["Meta"].([]string)
//		categoryName := i["CategoryName"].([]string)
//
//		for k, v := range i {
//			if k == "StringsToMatch" || k == "MetaRules" || k == "Meta" || k == "CategoryName" {
//				continue
//			}
//			malware[k] = v
//		}
//
//		for k, v := range metaRules {
//			if k != "" && v != "" {
//				key := fmt.Sprintf("%v[%v]", "metaRules", k)
//				malware[key] = v
//			}
//		}
//
//		for i, s := range match {
//			key := fmt.Sprintf("%v[%v]", "match", i)
//			malware[key] = s
//		}
//
//		for i, s := range meta {
//			key := fmt.Sprintf("%v[%v]", "meta", i)
//			malware[key] = s
//		}
//
//		for i, s := range categoryName {
//			key := fmt.Sprintf("%v[%v]", "category", i)
//			malware[key] = s
//		}
//
//		malware["rule_name"] = fmt.Sprintf("%v:%v", i["RuleName"], i["host_name"])
//		malwareMap = append(malwareMap, malware)
//	}
//
//	if _, err = tx.Run("UNWIND $batch as row MERGE (n:Malware{node_id:row.rule_id}) MERGE (m:MalwareScan{node_id: row.scan_id, host_name: row.host_name, time_stamp: timestamp()}) MERGE (m) -[:DETECTED]-> (n) SET n+= row", map[string]interface{}{"batch": malwareMap}); err != nil {
//		return err
//	}
//
//	if _, err = tx.Run("MATCH (n:MalwareScan) MERGE (m:Node{node_id: n.host_name}) MERGE (n) -[:SCANNED]-> (m)", map[string]interface{}{}); err != nil {
//		return err
//	}
//
//	return tx.Commit()
//}

type MalwareScanStatusIngester struct{}

func NewMalwareScanStatusIngester() KafkaIngester[[]ingesters.MalwareScanStatus] {
	return &MalwareScanStatusIngester{}
}

func (tc *MalwareScanStatusIngester) Ingest(
	ctx context.Context,
	statuses []ingesters.MalwareScanStatus,
	ingestC chan *kgo.Record,
) error {
	tenantID, err := directory.ExtractNamespace(ctx)
	if err != nil {
		return err
	}

	rh := []kgo.RecordHeader{
		{Key: "tenant_id", Value: []byte(tenantID)},
	}

	for _, c := range statuses {
		cb, err := json.Marshal(c)
		if err != nil {
			log.Error().Msg(err.Error())
		} else {
			ingestC <- &kgo.Record{
				Topic:   utils.MALWARE_SCAN_STATUS,
				Value:   cb,
				Headers: rh,
			}
		}
	}

	return nil
}
