package ingesters

import (
	"fmt"
	"hash/fnv"
	"time"

	"github.com/deepfence/golang_deepfence_sdk/utils/directory"
	"github.com/deepfence/golang_deepfence_sdk/utils/utils"
	"github.com/neo4j/neo4j-go-driver/v4/neo4j"
)

type MalwareScanStatus struct {
	Timestamp  time.Time `json:"@timestamp"`
	ScanID     string    `json:"scan_id"`
	ScanStatus string    `json:"scan_status"`
}

type MalwareRule struct {
	RuleID      string `json:"rule_id"`
	RuleName    string `json:"rule_name"`
	Author      string `json:"author"`
	Date        string `json:"date"`
	Description string `json:"description"`
	Filetype    string `json:"filetype"`
	Info        string `json:"info"`
	Version     string `json:"version"`
}

type Malware struct {
	Timestamp        time.Time   `json:"@timestamp"`
	Class            string      `json:"Class"`
	CompleteFilename string      `json:"CompleteFilename"`
	FileSevScore     int         `json:"FileSevScore"`
	FileSeverity     string      `json:"FileSeverity"`
	ImageLayerID     string      `json:"ImageLayerId"`
	Meta             []string    `json:"Meta"`
	MetaRules        MalwareRule `json:"MetaRules"`
	RuleName         string      `json:"RuleName"`
	SeverityScore    int         `json:"SeverityScore"`
	StringsToMatch   []string    `json:"StringsToMatch"`
	Summary          string      `json:"Summary"`
	Masked           bool        `json:"masked"`
	ScanID           string      `json:"scan_id"`
}

func generateMalwareRuleId(metaRule MalwareRule) string {
	return generateHashFromString(metaRule.Author + metaRule.Date + metaRule.RuleName + metaRule.Info + metaRule.Filetype + metaRule.Version)
}

func generateHashFromString(s string) string {
	h := fnv.New32a()
	h.Write([]byte(s))
	return fmt.Sprintf("%x", h.Sum32())
}

func CommitFuncMalware(ns string, data []Malware) error {
	ctx := directory.NewContextWithNameSpace(directory.NamespaceID(ns))
	driver, err := directory.Neo4jClient(ctx)
	if err != nil {
		return err
	}

	session := driver.NewSession(neo4j.SessionConfig{AccessMode: neo4j.AccessModeWrite})
	if err != nil {
		return err
	}
	defer session.Close()

	tx, err := session.BeginTransaction()
	if err != nil {
		return err
	}
	defer tx.Close()

	if _, err = tx.Run(`
		UNWIND $batch as row WITH row.Rule as rule, row.Malware as malware
		MERGE (r:MalwareRule{rule_id:rule.rule_id})
		SET r+=rule WITH malware as row, r
		MERGE (n:Malware{node_id:row.node_id})
		SET n+= row
		WITH n, r, row
		MERGE (n)-[:IS]->(r)
		MERGE (m:MalwareScan{node_id: row.scan_id})
		WITH n, m
		MERGE (m) -[r:DETECTED]-> (n)
		SET r.masked = false`,
		map[string]interface{}{"batch": malwareToMaps(data)}); err != nil {
		return err
	}

	return tx.Commit()
}

func malwareToMaps(data []Malware) []map[string]map[string]interface{} {
	var malwares []map[string]map[string]interface{}
	for _, i := range data {
		malware := utils.ToMap(i)
		delete(malware, "MetaRules")

		i.MetaRules.RuleName = malware["RuleName"].(string)
		i.MetaRules.RuleID = generateMalwareRuleId(i.MetaRules)
		malware["node_id"] = generateHashFromString(fmt.Sprintf("%v:%v", i.MetaRules.RuleID, i.CompleteFilename))
		malwares = append(malwares, map[string]map[string]interface{}{
			"Rule":    utils.ToMap(i.MetaRules),
			"Malware": malware,
		})
	}
	return malwares
}
